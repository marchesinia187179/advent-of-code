//
// Created by Marchesini Alessandro on 14/12/25.
// ATTENTION: Only the comments are generated by LLM, but they have been read by the author!
//

#include "day_four.h"

#include <stdio.h>

/**
 * @brief Removes the 'accessible' rolls from the grid for the second part of the problem.
 * * Replaces the characters at the specified accessible positions in the grid with '.'.
 * * @param ptr Pointer to the start of the grid (2D array flattened).
 * @param accessible_rolls Array of flattened indices (offsets) of accessible rolls.
 * @param accessible_rolls_counter The number of accessible rolls in the array.
 */
void remove_accessible_rolls_second_part(char *ptr, int *accessible_rolls, int accessible_rolls_counter) {
    // Iterate through the list of accessible roll indices
    for (int i = 0; i < accessible_rolls_counter; i++) {
        // Use the index to set the corresponding element in the grid to '.' (removed)
        *(ptr + (accessible_rolls[i])) = '.';
    }
}

/**
 * @brief Counts the number of neighboring '@' rolls around a cell.
 * * Checks the 8 surrounding cells (including diagonals) for the '@' character.
 * * @param ptr Constant pointer to the start of the grid.
 * @param rows Total number of rows in the grid.
 * @param cols Total number of columns in the grid.
 * @param currRow The row index of the current cell.
 * @param currCol The column index of the current cell.
 * @return int The count of neighboring '@' characters.
 */
int close_rolls(const char *ptr, int rows, int cols, int currRow, int currCol) {
    int counter = 0;
    // Iterate over the 3x3 neighborhood centered at (currRow, currCol)
    for (int i = currRow - 1; i <= currRow + 1; i++) {
        for (int j = currCol - 1; j <= currCol + 1; j++) {
            // Check for boundaries (i.e., ensure (i, j) is inside the grid)
            if (i < 0 || i >= rows || j < 0 || j >= cols) continue;
            // Skip the center cell itself
            if (i == currRow && j == currCol) continue;

            // Check if the neighbor is an '@'
            if (*(ptr + (i * cols + j)) == '@') counter++;
        }
    }
    return counter;
}

/**
 * @brief Finds all accessible rolls in the current grid state.
 * * An accessible roll is an '@' character that has less than 4 neighboring '@' characters.
 * * @param ptr Pointer to the start of the grid.
 * @param rows Total number of rows.
 * @param cols Total number of columns.
 * @param accessible_rolls Array to store the flattened indices of accessible rolls.
 * @return int The total number of accessible rolls found.
 */
int get_accessible_rolls(char *ptr, int rows, int cols, int *accessible_rolls) {
    int accessible_rolls_counter = 0;

    // Iterate through every cell in the grid
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            // Check the character at the current position
            switch (*(ptr + (i * cols + j))) {
                case '@':
                    // Check the "accessibility" condition: fewer than 4 close rolls
                    if (close_rolls(ptr, rows, cols, i, j) < 4) {
                        // Store the flattened index (i * cols + j)
                        accessible_rolls[accessible_rolls_counter] = i * cols + j;
                        accessible_rolls_counter++;
                    }
                    break;
                default:
                    // Handle other characters (if any, though in this context, mostly '.' and '@' expected)
                    break;
            }
        }
    }

    return accessible_rolls_counter;
}

/**
 * @brief Reads the grid data from the file into the 2D array.
 * * Reads characters row by row, ignoring the newline character after each row.
 * * @param f The file pointer.
 * @param ptr Pointer to the start of the grid memory.
 * @param rows Total number of rows to read.
 * @param cols Total number of columns to read.
 */
void get_lines(FILE *f, char *ptr, int rows, int cols) {
    char c;
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            c = fgetc(f);
            // Store the character in the grid
            *(ptr + (i * cols + j)) = c;
        }
        fgetc(f);   // Consume the newline character ('\n') after each row
    }
}

/**
 * @brief Determines the dimensions (rows and columns) of the grid in the file.
 * * Scans the file content to count rows and columns, then rewinds the file.
 * Assumes a rectangular grid.
 * * @param f The file pointer.
 * @param rows Pointer to store the calculated number of rows.
 * @param cols Pointer to store the calculated number of columns.
 * @return int 0 on success, -1 if the file is empty.
 */
int get_dimensions(FILE *f, int *rows, int *cols) {
    *rows = 0, *cols = 0;

    int char_count = 0;
    char c;
    // Read character by character until EOF
    while ((c = fgetc(f)) != EOF) {
        if (c == '\n') {
            (*rows)++;
            char_count = 0;
        } else {
            (*cols)++;
            char_count++;
        }
    }
    // Handle the case where the last line doesn't end with '\n'
    if (char_count != 0) (*rows)++;

    // Calculate the actual number of columns per row
    *cols = *cols / *rows;

    // Reset file pointer to the beginning for subsequent reading
    rewind(f);

    // Return an error if no columns were found (empty file)
    return (*cols == 0) * -1;
}

/**
 * @brief Main function for day four processing.
 * * Opens the input file, determines grid dimensions, reads the grid, and calculates
 * the accessible rolls for two different scenarios (cases).
 * * @param fileName The path to the input file.
 * @return int 0 on success, 1 on file error or dimension error.
 */
int day_four_main(char *fileName) {
    // Open the input file for reading
    FILE *f = fopen(fileName, "r");
    if (f == NULL) {
        printf("Error opening file %s\n", fileName);
        return 1;
    }

    int cols, rows;
    // Get the grid dimensions
    if (get_dimensions(f, &rows, &cols) != 0) {
        printf("Error getting dimensions\n");
        fclose(f);
        return 1;
    }

    // Declare the 2D grid array (stored contiguously)
    char lines[rows][cols];
    // Read the grid data from the file
    get_lines(f, &lines[0][0], rows, cols);

    // Arrays to store the positions of accessible rolls and a counter for the current list
    int accessible_rolls_position[rows * cols];
    int accessible_rolls_counter = 0;
    int accessible_rolls_number = 0; // Total count for the result

    // --- First case (Find accessible rolls in the initial state) ---
    accessible_rolls_number = get_accessible_rolls(&lines[0][0], rows, cols, accessible_rolls_position);
    printf("Total rolls first case: %d\n", accessible_rolls_number);

    // --- Second case (Find total accessible rolls after iterative removal) ---
    accessible_rolls_number = 0;
    // Loop until no more accessible rolls are found in the current grid state
    while ((accessible_rolls_counter = get_accessible_rolls(&lines[0][0], rows, cols, accessible_rolls_position))) {
        // Add the newly found accessible rolls to the total count
        accessible_rolls_number += accessible_rolls_counter;
        // Remove the newly found rolls from the grid for the next iteration
        remove_accessible_rolls_second_part(&lines[0][0], accessible_rolls_position, accessible_rolls_counter);
    }
    printf("Total rolls second case: %d\n", accessible_rolls_number);

    // Close the file
    fclose(f);
    return 0;
}
